# -*- coding: utf-8 -*-
"""Train.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14HGv1NneJ5BKXoTokMRYQPAberSc4DWJ
"""

!pip install geopy
!pip install folium

from google.colab import drive
import pandas as pd

# Mount Google Drive
drive.mount('/content/drive')

path_csv="/content/drive/MyDrive/Colab Notebook/SNCF/tgvmax.db"

import sqlite3
import csv
from geopy.geocoders import Nominatim
from geopy.distance import geodesic
import os

# Connexion √† la base (elle sera cr√©√©e si elle n'existe pas)
# We use a path that is likely to be writable in Colab
db_path = path_csv
conn = sqlite3.connect(r"/content/drive/MyDrive/Colab Notebook/SNCF/tgvmax.db")
cur = conn.cursor()

def SQL(a):
    cur.execute(a)
    return(cur.fetchall())

"""Now you can run the following cells to get user input and perform the distance calculation."""

#ville de d√©part destination disponible, horaire, temps de trajets
ville_dep=input("ville de d√©part : ")

pattern_1 = f"%{ville_dep}%"

sql = """
SELECT DISTINCT Origine, Destination,
       TIME(Heure_depart) AS heure_depart,
       TIME(Heure_arrivee) AS heure_arrivee,
       -- Calculate duration in seconds and convert to HH:MM:SS format
       strftime('%H:%M:%S', (julianday(Heure_arrivee) - julianday(Heure_depart)) * 86400, 'unixepoch') AS duree
FROM tgvmax_trajets
WHERE LOWER(Origine) LIKE LOWER(?)
"""
cur.execute(sql, (pattern_1,))
resultats = cur.fetchall()
print(resultats)

# Import necessary libraries
import sqlite3
import pandas as pd
from datetime import datetime

# Assuming 'conn' and 'cur' are already connected to your database
# If not, you'll need to establish the connection here:
# db_path = "/content/drive/MyDrive/Colab Notebook/SNCF/tgvmax.db" # Replace with your actual path
# try:
#     conn = sqlite3.connect(db_path)
#     cur = conn.cursor()
#     print("‚úÖ Connexion √† la base de donn√©es r√©ussie.")
# except Exception as e:
#     print(f"‚ùå Erreur de connexion √† la base de donn√©es : {e}")


def find_train_journeys_by_date(ville_depart, date_depart):
    """
    Finds train journeys from a departure city on a specific date.

    Args:
        ville_depart (str): The departure city.
        date_depart (datetime.date): The desired departure date.

    Returns:
        list: A list of tuples representing the train journeys, or an empty list.
    """
    # Clean the city name for better matching
    pattern_dep = f"%{clean_city_name(ville_depart)}%"

    # Format the date for SQL query
    date_str = date_depart.strftime('%Y-%m-%d')

    # SQL query to select journeys from the origin city on the specified date
    sql = """
    SELECT Origine, Destination,
           TIME(Heure_depart) AS heure_depart,
           TIME(Heure_arrivee) AS heure_arrivee,
           strftime('%H:%M:%S', (julianday(Heure_arrivee) - julianday(Heure_depart)) * 86400, 'unixepoch') AS duree
    FROM tgvmax_trajets
    WHERE LOWER(Origine) LIKE LOWER(?)
      AND DATE = ?
    ORDER BY Heure_depart ASC
    """

    try:
        cur.execute(sql, (pattern_dep, date_str))
        results = cur.fetchall()
        return results
    except sqlite3.Error as e:
        print(f"Database error: {e}")
        return []
    except Exception as e:
        print(f"An error occurred: {e}")
        return []

# --- Example Usage ---
# Get user input for departure city and date
departure_city = input("Enter the departure city: ")
date_input_str = input("Enter the departure date (YYYY-MM-DD): ")

try:
    # Convert the input string to a date object
    departure_date = datetime.strptime(date_input_str, '%Y-%m-%d').date()

    # Find and display the train journeys
    journeys = find_train_journeys_by_date(departure_city, departure_date)

    if journeys:
        print(f"\nTrain journeys from {departure_city} on {date_input_str}:")
        # Display results in a more readable format, e.g., using pandas
        df_journeys = pd.DataFrame(journeys, columns=['Origin', 'Destination', 'Departure Time', 'Arrival Time', 'Duration'])
        display(df_journeys)
    else:
        print(f"\nNo train journeys found from {departure_city} on {date_input_str}.")

except ValueError:
    print("Invalid date format. Please use YYYY-MM-DD.")
except Exception as e:
    print(f"An error occurred during processing: {e}")

#ville de d√©part et ville d'arriver
ville_dest=input("destination : ")
print(ville_dep,ville_dest)

pattern_2 = f"%{ville_dest}%"

sql = """
SELECT DISTINCT Origine, Destination,
       TIME(Heure_depart) AS heure_depart,
       TIME(Heure_arrivee) AS heure_arrivee,
       -- Calculate duration in seconds and convert to HH:MM:SS format
       strftime('%H:%M:%S', (julianday(Heure_arrivee) - julianday(Heure_depart)) * 86400, 'unixepoch') AS duree
FROM tgvmax_trajets
WHERE LOWER(Origine) LIKE LOWER(?) AND LOWER(Destination) LIKE LOWER(?)
"""
cur.execute(sql, (pattern_1,pattern_2))
resultats2 = cur.fetchall()
print(resultats2)

def distance_villes(ville_dep,ville_dest):
  #d√©termination de la distance entre ville_dep et ville_dest
  # Cr√©ation d'un g√©ocodeur (utilise OpenStreetMap)
  geolocator = Nominatim(user_agent="distance_calculator")

  # Recherche des coordonn√©es GPS
  loc_dep = geolocator.geocode(ville_dep)
  loc_dest = geolocator.geocode(ville_dest)

  distance_km = None # Initialize distance_km

  if loc_dep and loc_dest:
      coord_dep = (loc_dep.latitude, loc_dep.longitude)
      coord_dest = (loc_dest.latitude, loc_dest.longitude)

      # Calcul de la distance √† vol d'oiseau
      distance_km = geodesic(coord_dep, coord_dest).kilometers

  return(distance_km)

print(f"Distance entre {ville_dep} et {ville_dest} : {distance_villes(ville_dep,ville_dest):.2f} km")

print(distance_villes("NICE VILLE","ROUEN"))

distance_max=input("disantce maximal parcourue (km)")

#ville de d√©part destination disponible, horaire, temps de trajets
ville_dep=input("ville de d√©part : ")

pattern_1 = f"%{ville_dep}%"

sql = """
SELECT DISTINCT Origine, Destination
FROM tgvmax_trajets
WHERE LOWER(Origine) LIKE LOWER(?)
"""

cur.execute(sql, (pattern_1,))
resultats3 = cur.fetchall()
#print(resultats3)

unique_cities = set()
for i in resultats3:
  unique_cities.add(i[0])
  unique_cities.add(i[1])

import time
city_coordinates = {}
geolocator = Nominatim(user_agent="distance_calculator", timeout=10) # Increase timeout

for i, city in enumerate(unique_cities):
  try:
    # Add a small delay between requests to avoid overloading the server
    if i > 0:
        time.sleep(1) # Pause for 1 second between requests

    # Check for "(intramuros)" and replace with just the city name
    cleaned_city = city.replace(" (intramuros)", "")

    loc_dep = geolocator.geocode(cleaned_city)
    if loc_dep:
      city_coordinates[city] = (loc_dep.latitude, loc_dep.longitude)
    else:
      print(f"Could not geocode city: {city}") # Print cities that could not be geocoded

  except Exception as e:
    print(f"Error geocoding city {city}: {e}") # Print any other errors during geocoding
    continue # Continue with the next city if an error occurs

distances = []
for i in resultats3:
  origine = i[0]
  destination = i[1]
  origin_coords = city_coordinates.get(origine)
  destination_coords = city_coordinates.get(destination)

  distance_km = None
  if origin_coords and destination_coords:
    distance_km = geodesic(origin_coords, destination_coords).kilometers

  distances.append((origine, destination, distance_km))

print(distances)

filtered_results = []
try:
    distance_max_float = float(distance_max)
    for origin, destination, distance_km in distances:
      if distance_km is not None and distance_km < distance_max_float:
        filtered_results.append((origin, destination))

    for result in filtered_results:
        print(result)

except ValueError:
    print("Invalid input for maximum distance. Please enter a number.")

print(filtered_results)

import folium
from geopy.geocoders import Nominatim

# Get city name from user input
city_name_input = ville_dep.upper().strip()

# Geocode the city name to get coordinates
geolocator = Nominatim(user_agent="city_mapper")
location = geolocator.geocode(city_name_input)

if location:
    # Store the origin city coordinates
    origin_coords = (location.latitude, location.longitude)
    origin_city_key = city_name_input # Use the input as the key for simplicity

    # Create a map centered at the origin city
    m = folium.Map(location=origin_coords, zoom_start=10)

    # Add a red marker for the origin city
    folium.Marker(
        location=origin_coords,
        popup=origin_city_key,
        icon=folium.Icon(color='red')
    ).add_to(m)

    # Add a circle representing the maximum distance
    # Assuming distance_max_float and filtered_results are available from previous cells
    try:
        folium.Circle(
            location=origin_coords,
            radius=distance_max_float * 1000,  # Radius in meters
            color='blue',
            fill=True,
            fill_color='blue',
            fill_opacity=0.1
        ).add_to(m)

        # Add markers for the filtered destination cities
        for origin, destination in filtered_results:
            destination_coords = city_coordinates.get(destination)
            if destination_coords:
                folium.Marker(
                    location=destination_coords,
                    popup=destination,
                    icon=folium.Icon(color='green')
                ).add_to(m)

    except NameError:
        print("Please make sure 'distance_max_float', 'filtered_results', and 'city_coordinates' are defined by running previous cells.")


    # Display the map
    display(m)
else:
    print(f"Could not find coordinates for the origin city: {city_name_input}")

!pip install geodatamine

from geopy.geocoders import Nominatim
import folium

city_name = input("Enter the name of the city: ")

"""Next, we'll use `geodatamine` to fetch the tourist attractions and display them on a map. Please note that the available data and characteristics (like price) depend on what's available in the OpenStreetMap data for that specific location and category."""

geolocator = Nominatim(user_agent="city_mapper")
location = geolocator.geocode(city_name)

if location:
    # Create a map centered at the city
    m = folium.Map(location=[location.latitude, location.longitude], zoom_start=12)

    # Add a marker for the city
    folium.Marker(
        location=[location.latitude, location.longitude],
        popup=city_name,
        icon=folium.Icon(color='blue')
    ).add_to(m)

    # Display the map
    display(m)
else:
    print(f"Could not find coordinates for the city: {city_name}")

from geopy.geocoders import Nominatim
import folium
import pandas as pd
import requests # Import the requests library to query the Overpass API

# Get city name from user input
city_name = input("Enter the name of the city: ")

# Geocode the city name to get coordinates and bounding box
geolocator = Nominatim(user_agent="city_mapper")
location = geolocator.geocode(city_name, exactly_one=True)

if location:
    # Get the bounding box of the city
    # The bounding box is usually available in the 'raw' data from geopy
    if 'boundingbox' in location.raw:
        bbox = location.raw['boundingbox']
        # The bounding box from Nominatim is typically [south, north, west, east]
        south, north, west, east = [float(x) for x in bbox]

        # Create a map centered at the city
        m = folium.Map(location=[location.latitude, location.longitude], zoom_start=12)

        # Add a marker for the city
        folium.Marker(
            location=[location.latitude, location.longitude],
            popup=city_name,
            icon=folium.Icon(color='blue')
        ).add_to(m)

        # --- Code to fetch data from Overpass API ---
        # Overpass API endpoint
        overpass_url = "http://overpass-api.de/api/interpreter"

        # Overpass query to get tourist attractions (restaurants, museums, etc.) within the bounding box
        # This is a basic query, you can refine it based on specific tags
        overpass_query = f"""
        [out:json];
        (
          node["amenity"="restaurant"]({south},{west},{north},{east});
          way["amenity"="restaurant"]({south},{west},{north},{east});
          relation["amenity"="restaurant"]({south},{west},{north},{east});
          node["tourism"="museum"]({south},{west},{north},{east});
          way["tourism"="museum"]({south},{west},{north},{east});
          relation["tourism"="museum"]({south},{west},{north},{east});
          node["tourism"="attraction"]({south},{west},{north},{east});
          way["tourism"="attraction"]({south},{west},{north},{east});
          relation["tourism"="attraction"]({south},{west},{north},{east});
        );
        out center;
        """

        try:
            response = requests.get(overpass_url, params={'data': overpass_query})
            response.raise_for_status() # Raise an exception for bad status codes
            data = response.json()

            # Process the data and add markers to the map
            if data and 'elements' in data:
                tourist_attractions_list = []
                for element in data['elements']:
                    # Use 'lat' and 'lon' for nodes, and 'center' for ways/relations
                    if element['type'] == 'node':
                        lat = element['lat']
                        lon = element['lon']
                    elif 'center' in element:
                        lat = element['center']['lat']
                        lon = element['center']['lon']
                    else:
                        continue # Skip elements without coordinates

                    name = element.get('tags', {}).get('name', 'Unnamed')
                    tags = element.get('tags', {})

                    # Construct popup HTML with relevant characteristics
                    popup_html = f"<b>{name}</b><br>"

                    # Add price/fee information if available
                    price_info = tags.get('price', tags.get('cost', tags.get('fee', 'N/A')))
                    popup_html += f"Price/Fee: {price_info}<br>"

                    # Add other relevant characteristics, excluding those already handled and diet tags for restaurants
                    for key, value in tags.items():
                        # Exclude common tags and diet tags if it's a restaurant
                        if key not in ['name', 'website', 'phone', 'price', 'cost', 'fee', 'amenity', 'tourism']:
                             if tags.get('amenity') == 'restaurant' and key.startswith('diet:'):
                                continue # Skip diet tags for restaurants
                             popup_html += f"{key}: {value}<br>"


                    # Determine marker color based on type
                    marker_color = 'green' # Default color
                    if tags.get('amenity') == 'restaurant':
                        marker_color = 'red'
                    elif tags.get('tourism') == 'museum':
                        marker_color = 'blue'


                    tourist_attractions_list.append({
                        'name': name,
                        'latitude': lat,
                        'longitude': lon,
                        'tags': tags # Store all tags for potential future use
                    })

                    folium.Marker(
                        location=[lat, lon],
                        popup=popup_html,
                        icon=folium.Icon(color=marker_color)
                    ).add_to(m)

                # Optionally, create a DataFrame from the collected data
                tourist_attractions_df = pd.DataFrame(tourist_attractions_list)
                if not tourist_attractions_df.empty:
                    print("Tourist Attractions Found:")
                    display(tourist_attractions_df)
                else:
                     print("No tourist attractions found matching the query.")


            else:
                print("No data elements found in Overpass API response.")

        except requests.exceptions.RequestException as e:
            print(f"Error querying Overpass API: {e}")
        except Exception as e:
            print(f"An error occurred while processing Overpass data: {e}")

        # Display the map
        display(m)
    else:
        print(f"Could not get bounding box for city: {city_name}")

else:
    print(f"Could not find coordinates for the city: {city_name}")

"""###Partie 2"""

from geopy.geocoders import Nominatim
from geopy.distance import geodesic
import folium
import requests
import time
from datetime import datetime, timedelta

def trouver_destinations_par_temps(ville_depart, temps_trajet_max_str):
    """
    Trouve les villes accessibles depuis une ville de d√©part dans un temps de trajet donn√©.

    Args:
        ville_depart (str): La ville de d√©part.
        temps_trajet_max_str (str): Le temps de trajet max au format "HH:MM:SS" (ex: "02:30:00").

    Returns:
        list: Une liste de tuples (Origine, Destination, Dur√©e).
    """
    pattern = f"%{ville_depart}%"
    sql = """
    SELECT
        Origine,
        Destination,
        strftime('%H:%M:%S', (julianday(Heure_arrivee) - julianday(Heure_depart)) * 86400, 'unixepoch') AS duree
    FROM
        tgvmax_trajets
    WHERE
        LOWER(Origine) LIKE LOWER(?)
        AND duree <= ?
    ORDER BY
        duree
    """
    cur.execute(sql, (pattern, temps_trajet_max_str))
    resultats = cur.fetchall()
    return resultats

# --- Exemple d'utilisation ---
ville_dep = "PARIS" # Mettez votre ville ici
temps_max = "02:00:00" # Je veux aller quelque part en moins de 2 heures

destinations_possibles = trouver_destinations_par_temps(ville_dep, temps_max)

if destinations_possibles:
    print(f"Destinations possibles depuis {ville_dep} en moins de {temps_max} :")
    df_destinations = pd.DataFrame(destinations_possibles, columns=['Origine', 'Destination', 'Dur√©e'])
    display(df_destinations)
else:
    print("Aucune destination trouv√©e dans ce laps de temps.")

def proposer_aller_retour(ville_depart, ville_arrivee, heure_depart_souhaitee_str, temps_sur_place_str):
    """
    Propose un trajet aller et un trajet retour optimaux.

    Args:
        ville_depart (str): La ville de d√©part.
        ville_arrivee (str): La ville d'arriv√©e.
        heure_depart_souhaitee_str (str): Heure de d√©part souhait√©e ("HH:MM").
        temps_sur_place_str (str): Temps √† passer sur place ("HH:MM").

    Returns:
        dict: Un dictionnaire contenant les informations du trajet aller et retour.
    """
    # --- TROUVER LE TRAJET ALLER ---
    pattern_dep = f"%{ville_depart}%"
    pattern_arr = f"%{ville_arrivee}%"
    sql_aller = """
    SELECT
        Origine, Destination, TIME(Heure_depart) AS heure_depart, TIME(Heure_arrivee) AS heure_arrivee
    FROM
        tgvmax_trajets
    WHERE
        LOWER(Origine) LIKE LOWER(?) AND LOWER(Destination) LIKE LOWER(?) AND TIME(Heure_depart) >= ?
    ORDER BY
        heure_depart ASC
    LIMIT 1
    """
    cur.execute(sql_aller, (pattern_dep, pattern_arr, heure_depart_souhaitee_str))
    trajet_aller = cur.fetchone()

    if not trajet_aller:
        return {"erreur": "Aucun trajet aller trouv√© apr√®s l'heure souhait√©e."}

    # --- CALCULER L'HEURE DE D√âPART POUR LE RETOUR ---
    heure_arrivee_aller = datetime.strptime(trajet_aller[3], '%H:%M:%S')
    temps_sur_place = datetime.strptime(temps_sur_place_str, '%H:%M')
    delta_temps_sur_place = timedelta(hours=temps_sur_place.hour, minutes=temps_sur_place.minute)
    heure_depart_retour_min = (heure_arrivee_aller + delta_temps_sur_place).strftime('%H:%M:%S')

    # --- TROUVER LE TRAJET RETOUR ---
    sql_retour = """
    SELECT
        Origine, Destination, TIME(Heure_depart) AS heure_depart, TIME(Heure_arrivee) AS heure_arrivee
    FROM
        tgvmax_trajets
    WHERE
        LOWER(Origine) LIKE LOWER(?) AND LOWER(Destination) LIKE LOWER(?) AND TIME(Heure_depart) >= ?
    ORDER BY
        heure_depart ASC
    LIMIT 1
    """
    cur.execute(sql_retour, (pattern_arr, pattern_dep, heure_depart_retour_min))
    trajet_retour = cur.fetchone()

    if not trajet_retour:
        return {"erreur": "Aucun trajet retour trouv√© apr√®s le temps sur place."}

    return {
        "aller": trajet_aller,
        "retour": trajet_retour
    }

# --- Exemple d'utilisation ---
itineraire = proposer_aller_retour("PARIS", "LYON", "09:00", "05:00") # D√©part 9h, 5h sur place

if "erreur" in itineraire:
    print(itineraire["erreur"])
else:
    print("Itin√©raire Sugg√©r√© :")
    print(f"  Aller  : D√©part de {itineraire['aller'][0]} √† {itineraire['aller'][2]}, arriv√©e √† {itineraire['aller'][1]} √† {itineraire['aller'][3]}")
    print(f"  Retour : D√©part de {itineraire['retour'][0]} √† {itineraire['retour'][2]}, arriv√©e √† {itineraire['retour'][1]} √† {itineraire['retour'][3]}")

def estimer_temps_visite(tags):
    """ Estime le temps de visite en minutes bas√© sur les tags OSM. """
    if tags.get('tourism') == 'museum' or tags.get('historic') == 'castle':
        return 120
    if tags.get('historic') in ['cathedral', 'church']:
        return 45
    if tags.get('tourism') == 'attraction' or tags.get('historic') == 'monument':
        return 30
    if tags.get('leisure') == 'park':
        return 60
    return 20 # 20 minutes par d√©faut pour les autres points d'int√©r√™t

def get_lieux_touristiques(nom_ville):
    """ R√©cup√®re les lieux touristiques d'une ville via Overpass API. """
    # Initialize geolocator within the function scope
    geolocator = Nominatim(user_agent="city_mapper", timeout=10)

    location = geolocator.geocode(nom_ville, exactly_one=True)
    if not location or 'boundingbox' not in location.raw:
        print(f"Impossible de trouver les coordonn√©es/limites pour {nom_ville}")
        return []

    bbox = location.raw['boundingbox']
    south, north, west, east = [float(x) for x in bbox]

    overpass_url = "http://overpass-api.de/api/interpreter"
    # Requ√™te plus compl√®te pour plus de lieux
    overpass_query = f"""
    [out:json][timeout:25];
    (
      node["tourism"~"museum|attraction|gallery|viewpoint"]({south},{west},{north},{east});
      way["tourism"~"museum|attraction|gallery|viewpoint"]({south},{west},{north},{east});
      node["historic"~"castle|monument|ruins|cathedral|church"]({south},{west},{north},{east});
      way["historic"~"castle|monument|ruins|cathedral|church"]({south},{west},{north},{east});
    );
    out center;
    """
    try:
        response = requests.get(overpass_url, params={'data': overpass_query})
        response.raise_for_status()
        data = response.json()

        lieux = []
        for element in data.get('elements', []):
            tags = element.get('tags', {})
            name = tags.get('name', 'Sans nom')

            lat, lon = (0, 0)
            if element['type'] == 'node':
                lat, lon = element['lat'], element['lon']
            elif 'center' in element:
                lat = element['center']['lat']
                lon = element['center']['lon']
            else:
                continue

            # Ajout de l'estimation du temps et d'un score (simple pour le moment)
            temps = estimer_temps_visite(tags)
            score = tags.get('wikipedia') is not None # Le lieu a une page Wikipedia ? C'est un bon indicateur d'importance.

            lieux.append({
                'nom': name,
                'latitude': lat,
                'longitude': lon,
                'tags': tags,
                'temps_visite_min': temps,
                'score_pertinence': 1 if score else 0 # 1 si page wiki, 0 sinon
            })
        return lieux
    except requests.exceptions.RequestException as e:
        print(f"Erreur API Overpass : {e}")
        return []

# --- Exemple d'utilisation ---
lieux_a_lyon = get_lieux_touristiques("toulouse matabiau")
if lieux_a_lyon:
    df_lieux = pd.DataFrame(lieux_a_lyon)
    # Trier par pertinence (score) puis par nom
    df_lieux_tries = df_lieux.sort_values(by=['score_pertinence', 'nom'], ascending=[False, True])
    print("Lieux touristiques trouv√©s √† Lyon :")
    display(df_lieux_tries.head(10)) # Afficher les 10 plus pertinents
else:
    print("Aucun lieu touristique trouv√©.")

def calculer_temps_trajet_a_pied(coords1, coords2, vitesse_kmh=4.5):
    """
    Calcule le temps de trajet √† pied en minutes entre deux points GPS.

    Args:
        coords1 (tuple): (latitude, longitude) du point de d√©part.
        coords2 (tuple): (latitude, longitude) du point d'arriv√©e.
        vitesse_kmh (float): Vitesse de marche moyenne en km/h.

    Returns:
        float: Le temps de trajet estim√© en minutes.
    """
    if not coords1 or not coords2:
        return 0

    # Calcule la distance en kilom√®tres
    distance_km = geodesic(coords1, coords2).kilometers

    # Calcule le temps en heures, puis le convertit en minutes
    temps_heures = distance_km / vitesse_kmh
    temps_minutes = temps_heures * 60

    return round(temps_minutes)

def creer_itineraire_visite_avec_trajet(lieux_tries, temps_disponible_min):
    """
    Cr√©e un itin√©raire de visite en s√©lectionnant les lieux les plus pertinents,
    en incluant le temps de trajet √† pied entre chaque lieu.
    """
    itineraire = []
    temps_total = 0

    if not lieux_tries:
        return [], 0

    # 1. Ajouter le premier lieu (le plus important), sans temps de trajet initial
    premier_lieu = lieux_tries[0]
    if premier_lieu['temps_visite_min'] <= temps_disponible_min:
        itineraire.append(premier_lieu)
        temps_total += premier_lieu['temps_visite_min']
    else:
        # Si on n'a m√™me pas le temps de visiter le premier lieu, on s'arr√™te.
        return [], 0

    # 2. Parcourir le reste des lieux pour voir si on peut les ajouter
    for lieu_candidat in lieux_tries[1:]:
        # Le point de d√©part est le dernier lieu ajout√© √† notre itin√©raire
        dernier_lieu_visite = itineraire[-1]

        coords_dernier_lieu = (dernier_lieu_visite['latitude'], dernier_lieu_visite['longitude'])
        coords_candidat = (lieu_candidat['latitude'], lieu_candidat['longitude'])

        # 3. Calculer le temps de trajet
        temps_trajet = calculer_temps_trajet_a_pied(coords_dernier_lieu, coords_candidat)

        temps_visite_candidat = lieu_candidat['temps_visite_min']

        # 4. V√©rifier si on a le temps d'y aller ET de le visiter
        if temps_total + temps_trajet + temps_visite_candidat <= temps_disponible_min:
            # On stocke le temps de trajet pour l'afficher plus tard
            lieu_candidat['trajet_depuis_precedent'] = temps_trajet
            itineraire.append(lieu_candidat)
            temps_total += temps_trajet + temps_visite_candidat

    return itineraire, temps_total

# --- Exemple d'utilisation (√† placer apr√®s avoir r√©cup√©r√© les lieux de Lyon) ---

# On suppose que df_lieux_tries existe et a √©t√© cr√©√© comme dans la r√©ponse pr√©c√©dente
temps_sur_place_a_lyon_min = 5 * 60 # 5 heures

lieux_tries_list = df_lieux_tries.to_dict('records')
itineraire_lyon, temps_utilise = creer_itineraire_visite_avec_trajet(lieux_tries_list, temps_sur_place_a_lyon_min)

if itineraire_lyon:
    print(f"Itin√©raire de visite OPTIMIS√â pour Lyon ({temps_utilise / 60:.1f}h sur {temps_sur_place_a_lyon_min / 60:.1f}h disponibles):")

    # Affiche le premier lieu
    lieu = itineraire_lyon[0]
    print(f"  1. {lieu['nom']} (Visite : {lieu['temps_visite_min']} min)")

    # Affiche les lieux suivants avec le temps de trajet
    for i, lieu in enumerate(itineraire_lyon[1:], start=2):
        print(f"     -> Trajet √† pied : {lieu['trajet_depuis_precedent']} min")
        print(f"  {i}. {lieu['nom']} (Visite : {lieu['temps_visite_min']} min)")

    print(f"\nTemps total estim√© (visites + trajets) : {temps_utilise} minutes.")
else:
    print("Pas assez de temps pour visiter des lieux.")

#voir fonction ci-dessus

def creer_itineraire_visite(lieux_tries, temps_disponible_min):
    """
    Cr√©e un itin√©raire de visite en s√©lectionnant les lieux les plus pertinents
    dans la limite du temps disponible.
    """
    itineraire = []
    temps_total = 0
    for lieu in lieux_tries:
        if temps_total + lieu['temps_visite_min'] <= temps_disponible_min:
            itineraire.append(lieu)
            temps_total += lieu['temps_visite_min']
    return itineraire, temps_total

# --- Exemple d'utilisation ---
temps_sur_place_a_lyon_min = 5 * 60 # 5 heures

# On r√©utilise le dataframe tri√© de l'√©tape pr√©c√©dente
lieux_tries_list = df_lieux_tries.to_dict('records')
itineraire_lyon, temps_utilise = creer_itineraire_visite(lieux_tries_list, temps_sur_place_a_lyon_min)

if itineraire_lyon:
    print(f"Itin√©raire de visite propos√© pour Lyon ({temps_utilise / 60:.1f}h sur {temps_sur_place_a_lyon_min / 60:.1f}h disponibles):")
    for i, lieu in enumerate(itineraire_lyon):
        print(f"  {i+1}. {lieu['nom']} (Visite estim√©e : {lieu['temps_visite_min']} min)")
else:
    print("Pas assez de temps pour visiter des lieux.")

def generer_carte_recommandation(ville_depart, destinations, itineraire_choisi, ville_choisie, geolocator):
    """
    G√©n√®re une carte Folium avec la ville de d√©part, les destinations possibles et
    l'itin√©raire de visite pour la destination recommand√©e.
    """
    # Centrer la carte sur la ville de d√©part
    loc_depart = geolocator.geocode(ville_depart)
    if not loc_depart:
        return "Impossible de g√©olocaliser la ville de d√©part."

    m = folium.Map(location=[loc_depart.latitude, loc_depart.longitude], zoom_start=7)

    # Marqueur pour le d√©part
    folium.Marker(
        location=[loc_depart.latitude, loc_depart.longitude],
        popup=f"<b>D√©part : {ville_depart}</b>",
        icon=folium.Icon(color='red', icon='train', prefix='fa')
    ).add_to(m)

    # Marqueurs pour les autres destinations possibles
    for dest in destinations:
        ville_dest_nom = dest[1]
        if ville_dest_nom != ville_choisie:
            try:
                loc_dest = geolocator.geocode(clean_city_name(ville_dest_nom))
                if loc_dest:
                    folium.Marker(
                        location=[loc_dest.latitude, loc_dest.longitude],
                        popup=f"<i>{ville_dest_nom}</i><br>Dur√©e : {dest[2]}",
                        icon=folium.Icon(color='blue', icon='info-sign')
                    ).add_to(m)
            except: continue

    # Marqueurs pour l'itin√©raire recommand√© dans la ville choisie
    for i, lieu in enumerate(itineraire_choisi):
        popup_html = f"<b>{i+1}. {lieu['nom']}</b><br>Visite: {lieu['temps_visite_min']} min"
        if 'trajet_depuis_precedent' in lieu:
            popup_html = f"Trajet: {lieu['trajet_depuis_precedent']} min<br>" + popup_html
        folium.Marker(
            location=[lieu['latitude'], lieu['longitude']],
            popup=popup_html,
            icon=folium.Icon(color='green', icon='camera', prefix='fa')
        ).add_to(m)

    return m

# --- EXEMPLE DE SYNTH√àSE COMPL√àTE ---
# 1. D√©finir les conditions de l'utilisateur
VILLE_DEPART = "marmande"
TEMPS_TRAJET_MAX = "02:00:00" # Moins de 2h00 de trajet
TEMPS_SUR_PLACE_MIN = 6 * 60 # 6 heures de visite

print("=============================================")
print(f"üöÄ Lancement de la recherche d'itin√©raire")
print(f"   Ville de d√©part : {VILLE_DEPART}")
print(f"   Temps de trajet max : {TEMPS_TRAJET_MAX}")
print(f"   Temps sur place : {TEMPS_SUR_PLACE_MIN / 60} heures")
print("=============================================\n")


# 2. Trouver toutes les destinations qui correspondent
destinations_candidates = trouver_destinations_par_temps(VILLE_DEPART, TEMPS_TRAJET_MAX)
destinations_uniques = sorted(list(set([d[1] for d in destinations_candidates]))) # Garder seulement les noms de villes uniques
print(f"üîé {len(destinations_uniques)} destinations uniques trouv√©es en moins de {TEMPS_TRAJET_MAX} de trajet.\n")

# 3. √âvaluer chaque destination
meilleure_destination = None
meilleur_itineraire = []
max_score = -1

for ville in destinations_uniques:
    print(f"üèôÔ∏è  Analyse de : {ville}...")
    lieux = get_lieux_touristiques(ville)

    if not lieux:
        print("   -> Aucun lieu touristique trouv√©.\n")
        continue

    # Trier les lieux par pertinence (score wikipedia)
    lieux_tries = sorted(lieux, key=lambda x: x['score_pertinence'], reverse=True)

    # Cr√©er un itin√©raire optimis√©
    itineraire_ville, temps_total_visite = creer_itineraire_visite_avec_trajet(lieux_tries, TEMPS_SUR_PLACE_MIN)

    # "Noter" cette destination par le nombre de lieux visitables (crit√®re simple mais efficace)
    score_actuel = len(itineraire_ville)
    print(f"   -> Score : {score_actuel} activit√©s possibles en {temps_total_visite} min.")

    if score_actuel > max_score:
        max_score = score_actuel
        meilleure_destination = ville
        meilleur_itineraire = itineraire_ville
    print("-" * 20)


# 4. Afficher la recommandation
if meilleure_destination:
    print("\n\n=============================================")
    print("üèÜ RECOMMANDATION N¬∞1 üèÜ")
    print(f"La meilleure destination est : {meilleure_destination} avec {max_score} activit√©s possibles !")
    print("=============================================\n")
    print("üìã Itin√©raire de visite sugg√©r√© sur place :")

    lieu = meilleur_itineraire[0]
    print(f"  1. {lieu['nom']} (Visite : {lieu['temps_visite_min']} min)")
    for i, lieu in enumerate(meilleur_itineraire[1:], start=2):
        print(f"     -> Trajet √† pied : ~{lieu['trajet_depuis_precedent']} min")
        print(f"  {i}. {lieu['nom']} (Visite : {lieu['temps_visite_min']} min)")

    # 5. G√©n√©rer la carte finale
    print("\nüó∫Ô∏è  G√©n√©ration de la carte...")
    carte_finale = generer_carte_recommandation(VILLE_DEPART, destinations_candidates, meilleur_itineraire, meilleure_destination, geolocator)
    display(carte_finale)
else:
    print("\n‚ùå D√©sol√©, aucune destination n'a √©t√© trouv√©e correspondant √† tous vos crit√®res.")

# ==============================================================================
# BLOC 1 : INSTALLATION, IMPORTS ET CONFIGURATION
# ==============================================================================

# --- Installation des biblioth√®ques ---
!pip install geopy folium requests pandas -q

# --- Imports ---
import sqlite3
import pandas as pd
from geopy.geocoders import Nominatim
from geopy.distance import geodesic
import folium
import requests
import re
from IPython.display import display
from datetime import datetime, timedelta

# --- Connexion √† la base de donn√©es ---
# !!! ATTENTION : Modifiez ce chemin si n√©cessaire !!!
db_path = "/content/drive/MyDrive/Colab Notebook/SNCF/tgvmax.db"
try:
    conn = sqlite3.connect(db_path)
    cur = conn.cursor()
    print("‚úÖ Connexion √† la base de donn√©es r√©ussie.")
except Exception as e:
    print(f"‚ùå Erreur de connexion √† la base de donn√©es : {e}")
    print("Veuillez v√©rifier que le chemin d'acc√®s est correct et que votre Drive est mont√©.")

# --- Initialisation du g√©ocodeur ---
geolocator = Nominatim(user_agent="mon_appli_itineraire_v2", timeout=10)

# ==============================================================================
# BLOC 2 : FONCTIONS UTILITAIRES (HELPERS)
# ==============================================================================

def clean_city_name(city_name):
    """Nettoie le nom d'une ville en supprimant les mentions comme '(intramuros)' et les gares."""
    if not isinstance(city_name, str):
        return ""
    # Remove "(intramuros)" and any leading/trailing whitespace
    cleaned_name = re.sub(r'\s*\([^)]*\)$', '', city_name).strip()
    # Remove common station names like "MATABIAU", "ST JEAN", "VILLE BOURBON", "ST CHARLES", "PART DIEU", etc.
    cleaned_name = re.sub(r'\s*(ST JEAN|MATABIAU|VILLE BOURBON|ST CHARLES|PART DIEU|SAINT LAUD|MONTPARNASSE|EST|NORD|LYON|AUSTERLITZ)\s*$', '', cleaned_name, flags=re.IGNORECASE).strip()
    # Specifically handle "TOULOUSE MATABIAU"
    if cleaned_name.lower() == "toulouse":
        return "TOULOUSE" # Or "TOULOUSE MATABIAU" depending on how the database is structured
    return cleaned_name

def estimer_temps_visite(tags):
    """Estime le temps de visite en minutes bas√© sur les tags OSM."""
    if tags.get('tourism') == 'museum' or tags.get('historic') == 'castle':
        return 120  # 2 heures
    if tags.get('historic') in ['cathedral', 'church']:
        return 45   # 45 minutes
    if tags.get('tourism') == 'attraction' or tags.get('historic') == 'monument':
        return 30   # 30 minutes
    if tags.get('leisure') == 'park':
        return 60   # 1 heure
    return 20 # 20 minutes par d√©faut

def calculer_temps_trajet_a_pied(coords1, coords2, vitesse_kmh=4.5):
    """Calcule le temps de trajet √† pied en minutes entre deux points GPS."""
    if not coords1 or not coords2:
        return 0

    try:
        distance_km = geodesic(coords1, coords2).kilometers
    except ValueError:
        # Handle cases where coordinates are invalid
        return 0

    temps_minutes = (distance_km / vitesse_kmh) * 60
    return round(temps_minutes)

# ==============================================================================
# BLOC 3 : FONCTIONS PRINCIPALES (LOGIQUE DU PROJET)
# ==============================================================================

def trouver_destinations_par_temps(ville_depart, temps_trajet_max_str):
    """Trouve les villes accessibles depuis une ville de d√©part dans un temps de trajet donn√©."""
    pattern = f"%{clean_city_name(ville_depart)}%"
    sql = """
    SELECT Origine, Destination,
           strftime('%H:%M:%S', (julianday(Heure_arrivee) - julianday(Heure_depart)) * 86400, 'unixepoch') AS duree,
           TIME(Heure_depart) AS heure_depart,
           TIME(Heure_arrivee) AS heure_arrivee
    FROM tgvmax_trajets
    WHERE LOWER(Origine) LIKE LOWER(?) AND duree > '00:00:00' AND duree <= ?
    ORDER BY duree
    """
    cur.execute(sql, (pattern, temps_trajet_max_str))
    return cur.fetchall()

def get_lieux_touristiques(nom_ville):
    """R√©cup√®re les lieux touristiques d'une ville via Overpass API."""
    nom_ville_nettoye = clean_city_name(nom_ville)
    try:
        location = geolocator.geocode(nom_ville_nettoye, exactly_one=True)
        if not location or 'boundingbox' not in location.raw:
            print(f"   -> Info: Impossible de trouver les limites pour {nom_ville_nettoye}")
            return []
    except Exception as e:
        print(f"   -> Erreur de g√©ocodage pour {nom_ville_nettoye}: {e}")
        return []

    bbox = location.raw['boundingbox']
    south, north, west, east = [float(x) for x in bbox]
    overpass_url = "http://overpass-api.de/api/interpreter"
    overpass_query = f"""
    [out:json][timeout:25];
    (
      node["tourism"~"museum|attraction|gallery|viewpoint"]({south},{west},{north},{east});
      way["tourism"~"museum|attraction|gallery|viewpoint"]({south},{west},{north},{east});
      node["historic"~"castle|monument|ruins|cathedral|church"]({south},{west},{north},{east});
      way["historic"~"castle|monument|ruins|cathedral|church"]({south},{west},{north},{east});
    );
    out center;
    """
    try:
        response = requests.get(overpass_url, params={'data': overpass_query})
        response.raise_for_status()
        data = response.json()
        lieux = []
        for element in data.get('elements', []):
            tags = element.get('tags', {})
            if 'name' not in tags: continue # On ignore les lieux sans nom

            lat, lon = (element.get('lat'), element.get('lon')) if element['type'] == 'node' else (element.get('center', {}).get('lat'), element.get('center', {}).get('lon'))
            if not lat or not lon: continue

            lieux.append({
                'nom': tags['name'], 'latitude': lat, 'longitude': lon, 'tags': tags,
                'temps_visite_min': estimer_temps_visite(tags),
                'score_pertinence': 1 if 'wikipedia' in tags else 0
            })
        return lieux
    except requests.exceptions.RequestException as e:
        print(f"   -> Erreur API Overpass pour {nom_ville_nettoye}: {e}")
        return []

def creer_itineraire_visite_avec_trajet(lieux_tries, temps_disponible_min):
    """Cr√©e un itin√©raire de visite en incluant le temps de trajet √† pied."""
    itineraire = []
    temps_total = 0
    if not lieux_tries: return [], 0

    premier_lieu = lieux_tries[0]
    if premier_lieu['temps_visite_min'] <= temps_disponible_min:
        itineraire.append(premier_lieu)
        temps_total += premier_lieu['temps_visite_min']
    else:
        return [], 0

    for lieu_candidat in lieux_tries[1:]:
        dernier_lieu_visite = itineraire[-1]
        coords_dernier_lieu = (dernier_lieu_visite['latitude'], dernier_lieu_visite['longitude'])
        coords_candidat = (lieu_candidat['latitude'], lieu_candidat['longitude'])
        temps_trajet = calculer_temps_trajet_a_pied(coords_dernier_lieu, coords_candidat)

        if temps_total + temps_trajet + lieu_candidat['temps_visite_min'] <= temps_disponible_min:
            lieu_candidat['trajet_depuis_precedent'] = temps_trajet
            itineraire.append(lieu_candidat)
            temps_total += temps_trajet + lieu_candidat['temps_visite_min']

    return itineraire, temps_total

def trouver_train_ideal(ville_depart, ville_arrivee, heure_min_depart_str):
    """
    Trouve le premier train disponible apr√®s une heure donn√©e pour un trajet direct.
    Retourne un tuple (origine, destination, duree, heure_depart, heure_arrivee) ou None.
    """
    pattern_dep = f"%{clean_city_name(ville_depart)}%"
    pattern_arr = f"%{clean_city_name(ville_arrivee)}%"
    sql = """
    SELECT Origine, Destination,
           strftime('%H:%M:%S', (julianday(Heure_arrivee) - julianday(Heure_depart)) * 86400, 'unixepoch') AS duree,
           TIME(Heure_depart) AS heure_depart,
           TIME(Heure_arrivee) AS heure_arrivee
    FROM tgvmax_trajets
    WHERE LOWER(Origine) LIKE LOWER(?) AND LOWER(Destination) LIKE LOWER(?) AND TIME(Heure_depart) >= ?
    ORDER BY TIME(Heure_depart) ASC
    LIMIT 1
    """
    cur.execute(sql, (pattern_dep, pattern_arr, heure_min_depart_str))
    return cur.fetchone()


def generer_carte_recommandation(ville_depart, destinations, itineraire_choisi, ville_choisie, geolocator):
    """G√©n√®re la carte Folium finale avec toutes les informations."""
    ville_depart_nettoyee = clean_city_name(ville_depart)
    loc_depart = geolocator.geocode(ville_depart_nettoyee)
    if not loc_depart:
        return "Impossible de g√©olocaliser la ville de d√©part."

    m = folium.Map(location=[loc_depart.latitude, loc_depart.longitude], zoom_start=7)

    folium.Marker(
        location=[loc_depart.latitude, loc_depart.longitude],
        popup=f"<b>D√©part : {ville_depart}</b>",
        icon=folium.Icon(color='red', icon='train', prefix='fa')
    ).add_to(m)

    # Add a red circle around the recommended destination
    loc_choisie = geolocator.geocode(clean_city_name(ville_choisie))
    if loc_choisie:
        folium.Circle(
            location=[loc_choisie.latitude, loc_choisie.longitude],
            radius=5000,  # Radius in meters (adjust as needed for visibility)
            color='red',
            fill=True,
            fill_color='red',
            fill_opacity=0.2,
            popup=f"Destination recommand√©e: {ville_choisie}"
        ).add_to(m)


    for dest in destinations:
        ville_dest_nom = dest[1]
        if ville_dest_nom != ville_choisie:
            try:
                loc_dest = geolocator.geocode(clean_city_name(ville_dest_nom))
                if loc_dest:
                    folium.Marker(
                        location=[loc_dest.latitude, loc_dest.longitude],
                        popup=f"<i>{ville_dest_nom}</i><br>Dur√©e : {dest[2]}",
                        icon=folium.Icon(color='blue', icon='info-sign')
                    ).add_to(m)
            except: continue


    # Marqueurs pour l'itin√©raire recommand√©
    for i, lieu in enumerate(itineraire_choisi):
        popup_html = f"<b>{i+1}. {lieu['nom']}</b><br>Visite: {lieu['temps_visite_min']} min"
        if 'trajet_depuis_precedent' in lieu:
            popup_html = f"Trajet: {lieu['trajet_depuis_precedent']} min<br>" + popup_html
        folium.Marker(
            location=[lieu['latitude'], lieu['longitude']],
            popup=popup_html,
            icon=folium.Icon(color='green', icon='camera', prefix='fa')
        ).add_to(m)

    return m

# ==============================================================================
# BLOC 4 : EX√âCUTION DU TEST AVEC INPUTS UTILISATEUR
# ==============================================================================

# --- 1. D√©finir les conditions de l'utilisateur (avec inputs) ---
VILLE_DEPART = input("Entrez votre ville de d√©part : ")
TEMPS_TRAJET_MAX = input("Entrez le temps de trajet maximum souhait√© (HH:MM:SS) : ")
temps_sur_place_heures = float(input("Entrez le temps que vous souhaitez passer sur place (en heures) : "))
TEMPS_SUR_PLACE_MIN = int(temps_sur_place_heures * 60) # Convertir en minutes
HEURE_DEPART_SOUHAITEE = input("Entrez l'heure de d√©part souhait√©e (HH:MM) : ")


print("=============================================")
print(f"üöÄ Lancement de la recherche d'itin√©raire")
print(f"   Ville de d√©part : {VILLE_DEPART}")
print(f"   Temps de trajet max : {TEMPS_TRAJET_MAX}")
print(f"   Temps sur place : {TEMPS_SUR_PLACE_MIN / 60} heures")
print(f"   Heure de d√©part souhait√©e : {HEURE_DEPART_SOUHAITEE}")
print("=============================================\n")


# --- 2. Trouver toutes les destinations candidates ---
destinations_candidates = trouver_destinations_par_temps(VILLE_DEPART, TEMPS_TRAJET_MAX)
# Create a list of unique destination names, keeping the first occurrence for train info
destinations_uniques_dict = {}
for dest in destinations_candidates:
    dest_name = dest[1]
    if dest_name not in destinations_uniques_dict:
        destinations_uniques_dict[dest_name] = dest

destinations_uniques_list = list(destinations_uniques_dict.values())


print(f"üîé {len(destinations_uniques_list)} destinations uniques trouv√©es en moins de {TEMPS_TRAJET_MAX} de trajet.\n")

# --- 3. √âvaluer chaque destination ---
meilleure_destination_info = None
meilleur_itineraire_visite = []
max_score = -1

for dest_info in destinations_uniques_list:
    ville_arrivee = dest_info[1] # Get the destination name
    print(f"üèôÔ∏è  Analyse de : {ville_arrivee}...")
    lieux = get_lieux_touristiques(ville_arrivee)

    if not lieux:
        print("   -> Aucun lieu touristique trouv√©.\n")
        continue

    # Trier les lieux par pertinence (score wikipedia)
    lieux_tries = sorted(lieux, key=lambda x: x['score_pertinence'], reverse=True)

    # Cr√©er un itin√©raire optimis√©
    itineraire_ville, temps_total_visite = creer_itineraire_visite_avec_trajet(lieux_tries, TEMPS_SUR_PLACE_MIN)

    # "Noter" cette destination par le nombre de lieux visitables (crit√®re simple mais efficace)
    score_actuel = len(itineraire_ville)
    print(f"   -> Score : {score_actuel} activit√©s possibles en {temps_total_visite} min.")

    if score_actuel > max_score:
        max_score = score_actuel
        meilleure_destination_info = dest_info # Store the full destination info
        meilleur_itineraire_visite = itineraire_ville # Store the best visit itinerary
    print("-" * 20)

# --- 4. Afficher la recommandation finale et le plan d√©taill√© ---
if meilleure_destination_info:
    ville_recommandee = meilleure_destination_info[1]

    # Trouver le train aller id√©al
    train_aller = trouver_train_ideal(VILLE_DEPART, ville_recommandee, HEURE_DEPART_SOUHAITEE)

    if not train_aller:
        print(f"\n‚ùå D√©sol√©, aucun train aller trouv√© depuis {VILLE_DEPART} vers {ville_recommandee} apr√®s {HEURE_DEPART_SOUHAITEE}.")
    else:
        print("\n\n=============================================")
        print("üèÜ RECOMMANDATION N¬∞1 üèÜ")
        print(f"La meilleure destination est : {ville_recommandee}")
        print("=============================================\n")
        print("üöÜ Itin√©raire D√©taill√© :")

        # Calcul des horaires
        heure_depart_aller_dt = datetime.strptime(train_aller[3], '%H:%M:%S')
        heure_arrivee_aller_dt = datetime.strptime(train_aller[4], '%H:%M:%S')
        temps_trajet_aller_td = heure_arrivee_aller_dt - heure_depart_aller_dt
        if temps_trajet_aller_td.total_seconds() < 0: # Handle overnight journeys
             temps_trajet_aller_td += timedelta(days=1)
        temps_trajet_aller_min = int(temps_trajet_aller_td.total_seconds() / 60)


        print(f"  1. Train Aller : D√©part de {train_aller[0]} √† {train_aller[3]} ({heure_depart_aller_dt.strftime('%H:%M')}), arriv√©e √† {train_aller[1]} √† {train_aller[4]} ({heure_arrivee_aller_dt.strftime('%H:%M')})")
        print(f"     Dur√©e du trajet : {train_aller[2]}")


        # Plan de visite sur place
        heure_debut_visite_dt = heure_arrivee_aller_dt
        heure_actuelle_dt = heure_debut_visite_dt

        print(f"\n  2. Visite de {ville_recommandee} : (Estimation sur place : {TEMPS_SUR_PLACE_MIN} min)")
        if meilleur_itineraire_visite:
            for i, lieu in enumerate(meilleur_itineraire_visite):
                if i > 0:
                    # Temps de trajet √† pied depuis le lieu pr√©c√©dent
                    temps_trajet_a_pied_min = lieu.get('trajet_depuis_precedent', 0)
                    heure_arrivee_lieu_dt = heure_actuelle_dt + timedelta(minutes=temps_trajet_a_pied_min)
                    print(f"     -> Trajet √† pied : ~{temps_trajet_a_pied_min} min (Arriv√©e estim√©e : {heure_arrivee_lieu_dt.strftime('%H:%M')})")
                    heure_actuelle_dt = heure_arrivee_lieu_dt

                # Temps de visite du lieu actuel
                temps_visite_lieu_min = lieu['temps_visite_min']
                heure_fin_visite_lieu_dt = heure_actuelle_dt + timedelta(minutes=temps_visite_lieu_min)
                print(f"     -> {i+1}. Visite de {lieu['nom']} ({temps_visite_lieu_min} min). (Fin estim√©e : {heure_fin_visite_lieu_dt.strftime('%H:%M')})")
                heure_actuelle_dt = heure_fin_visite_lieu_dt

            heure_fin_visite_totale_dt = heure_actuelle_dt
        else:
             print("     Aucun itin√©raire de visite d√©taill√© trouv√© pour cette destination dans le temps imparti.")
             # If no visit itinerary is found, the end of the visit is just the arrival time + buffer
             heure_fin_visite_totale_dt = heure_arrivee_aller_dt + timedelta(minutes=30) # Add a small buffer


        # Trouver le train retour id√©al
        heure_min_depart_retour_str = heure_fin_visite_totale_dt.strftime('%H:%M:%S')
        train_retour = trouver_train_ideal(ville_recommandee, VILLE_DEPART, heure_min_depart_retour_str)

        if train_retour:
             heure_depart_retour_dt = datetime.strptime(train_retour[3], '%H:%M:%S')
             heure_arrivee_retour_dt = datetime.strptime(train_retour[4], '%H:%M:%S')
             temps_trajet_retour_td = heure_arrivee_retour_dt - heure_depart_retour_dt
             if temps_trajet_retour_td.total_seconds() < 0: # Handle overnight journeys
                  temps_trajet_retour_td += timedelta(days=1)

             print(f"\n  3. Train Retour : D√©part de {train_retour[0]} √† {train_retour[3]} ({heure_depart_retour_dt.strftime('%H:%M')}), arriv√©e √† {train_retour[1]} √† {train_retour[4]} ({heure_arrivee_retour_dt.strftime('%H:%M')})")
             print(f"     Dur√©e du trajet : {train_retour[2]}")

             # Calcul du temps total
             temps_total_td = heure_arrivee_retour_dt - heure_depart_aller_dt
             if temps_total_td.total_seconds() < 0: # Handle cases spanning midnight
                 temps_total_td += timedelta(days=1)

             heures, remainder = divmod(temps_total_td.total_seconds(), 3600)
             minutes, seconds = divmod(remainder, 60)
             print(f"\nTemps total estim√© pour l'ensemble du voyage : {int(heures)}h {int(minutes)}min {int(seconds)}s")


        else:
             print(f"\n  3. Aucun train retour trouv√© depuis {ville_recommandee} vers {VILLE_DEPART} apr√®s {heure_min_depart_retour_str}.")


        # --- 5. G√©n√©rer et afficher la carte finale ---
        print("\nüó∫Ô∏è  G√©n√©ration de la carte...")
        carte_finale = generer_carte_recommandation(VILLE_DEPART, destinations_candidates, meilleur_itineraire_visite, ville_recommandee, geolocator)
        display(carte_finale)

else:
    print("\n‚ùå D√©sol√©, aucune destination n'a √©t√© trouv√©e correspondant √† tous vos crit√®res.")

"""Itin√©raire D√©taill√© :
  1. Train Aller : D√©part de LILLE (intramuros) √† 09:36:00 (09:36), arriv√©e √† DOUAI √† 09:58:00 (09:58)
     Dur√©e du trajet : 00:22:00

  2. Visite de DOUAI : (Estimation sur place : 300 min)
     -> 1. Visite de Mus√©e de la Chartreuse (120 min). (Fin estim√©e : 11:58)
     -> Trajet √† pied : ~11 min (Arriv√©e estim√©e : 12:09)
     -> 2. Visite de Beffroi (30 min). (Fin estim√©e : 12:39)
     -> Trajet √† pied : ~0 min (Arriv√©e estim√©e : 12:39)
     -> 3. Visite de Beffroi de Douai (20 min). (Fin estim√©e : 12:59)
     -> Trajet √† pied : ~9 min (Arriv√©e estim√©e : 13:08)
     -> 4. Visite de Ancien H√¥tel-Dieu (30 min). (Fin estim√©e : 13:38)
     -> Trajet √† pied : ~14 min (Arriv√©e estim√©e : 13:52)
     -> 5. Visite de Porte de Valenciennes ou Porte Vacqueresse (30 min). (Fin estim√©e : 14:22)

  3. Train Retour : D√©part de DOUAI √† 18:42:00 (18:42), arriv√©e √† LILLE (intramuros) √† 19:02:00 (19:02)
     Dur√©e du trajet : 00:20:00

Temps total estim√© pour l'ensemble du voyage : 9h 26min 0s

# Gradio :
"""

!pip install streamlit
!pip install gradio-folium

# ==============================================================================
# BLOC 1 : INSTALLATION, IMPORTS ET CONFIGURATION
# ==============================================================================

print("üöÄ Installation des biblioth√®ques...")
!pip install gradio geopy folium pandas gradio-folium -q
print("‚úÖ Installation termin√©e.")

import sqlite3
import pandas as pd
from geopy.geocoders import Nominatim
from geopy.distance import geodesic
import folium
import requests
import re
from datetime import datetime, timedelta
import gradio as gr
import gradio_folium as grf # Import gradio_folium

# --- Connexion √† la base de donn√©es ---
# Assurez-vous que votre Drive est mont√© et que le chemin est correct
db_path = "/content/drive/MyDrive/Colab Notebook/SNCF/tgvmax.db"
try:
    conn = sqlite3.connect(db_path, check_same_thread=False)
    cur = conn.cursor()
    print("‚úÖ Connexion √† la base de donn√©es r√©ussie.")
except Exception as e:
    print(f"‚ùå Erreur de connexion √† la base de donn√©es : {e}")

# --- Initialisation du g√©ocodeur ---
geolocator = Nominatim(user_agent="mon_appli_itineraire_gradio", timeout=10)

# ==============================================================================
# BLOC 2 : VOS FONCTIONS UTILITAIRES ET PRINCIPALES (INCHANG√âES)
# ==============================================================================
# (Toutes vos fonctions de l'√©tape pr√©c√©dente sont recopi√©es ici)

def clean_city_name(city_name):
    if not isinstance(city_name, str):
        return ""
    cleaned_name = re.sub(r'\s*\([^)]*\)$', '', city_name).strip()
    cleaned_name = re.sub(r'\s*(ST JEAN|MATABIAU|VILLE BOURBON|ST CHARLES|PART DIEU|SAINT LAUD|MONTPARNASSE|EST|NORD|LYON|AUSTERLITZ)\s*$', '', cleaned_name, flags=re.IGNORECASE).strip()
    if cleaned_name.lower() == "toulouse":
        return "TOULOUSE"
    return cleaned_name

def estimer_temps_visite(tags):
    if tags.get('tourism') == 'museum' or tags.get('historic') == 'castle':
        return 120
    if tags.get('historic') in ['cathedral', 'church']:
        return 45
    if tags.get('tourism') == 'attraction' or tags.get('historic') == 'monument':
        return 30
    if tags.get('leisure') == 'park':
        return 60
    return 20

def calculer_temps_trajet_a_pied(coords1, coords2, vitesse_kmh=4.5):
    if not coords1 or not coords2:
        return 0
    try:
        distance_km = geodesic(coords1, coords2).kilometers
    except ValueError:
        return 0
    return round((distance_km / vitesse_kmh) * 60)

def trouver_destinations_par_temps(ville_depart, temps_trajet_max_str):
    pattern = f"%{clean_city_name(ville_depart)}%"
    sql = "SELECT Origine, Destination, strftime('%H:%M:%S', (julianday(Heure_arrivee) - julianday(Heure_depart)) * 86400, 'unixepoch') AS duree, TIME(Heure_depart) AS heure_depart, TIME(Heure_arrivee) AS heure_arrivee FROM tgvmax_trajets WHERE LOWER(Origine) LIKE LOWER(?) AND duree > '00:00:00' AND duree <= ? ORDER BY duree"
    cur.execute(sql, (pattern, temps_trajet_max_str))
    return cur.fetchall()

def get_lieux_touristiques(nom_ville):
    nom_ville_nettoye = clean_city_name(nom_ville)
    try:
        location = geolocator.geocode(nom_ville_nettoye, exactly_one=True)
        if not location or 'boundingbox' not in location.raw:
            return []
    except Exception:
        return []
    bbox = location.raw['boundingbox']
    s, n, w, e = [float(x) for x in bbox]
    overpass_url = "http://overpass-api.de/api/interpreter"
    overpass_query = f"""[out:json][timeout:25];(node["tourism"~"museum|attraction|gallery|viewpoint"]({s},{w},{n},{e});way["tourism"~"museum|attraction|gallery|viewpoint"]({s},{w},{n},{e});node["historic"~"castle|monument|ruins|cathedral|church"]({s},{w},{n},{e});way["historic"~"castle|monument|ruins|cathedral|church"]({s},{w},{n},{e}););out center;"""
    try:
        response = requests.get(overpass_url, params={'data': overpass_query})
        data = response.json()
        lieux = []
        for element in data.get('elements', []):
            tags = element.get('tags', {})
            if 'name' not in tags:
                continue
            lat, lon = (element.get('lat'), element.get('lon')) if element['type'] == 'node' else (element.get('center', {}).get('lat'), element.get('center', {}).get('lon'))
            if not lat or not lon:
                continue
            lieux.append({'nom': tags['name'], 'latitude': lat, 'longitude': lon, 'tags': tags, 'temps_visite_min': estimer_temps_visite(tags), 'score_pertinence': 1 if 'wikipedia' in tags else 0})
        return lieux
    except requests.exceptions.RequestException:
        return []

def creer_itineraire_visite_avec_trajet(lieux_tries, temps_disponible_min):
    itineraire, temps_total = [], 0
    if not lieux_tries:
        return [], 0
    premier_lieu = lieux_tries[0]
    if premier_lieu['temps_visite_min'] <= temps_disponible_min:
        itineraire.append(premier_lieu)
        temps_total += premier_lieu['temps_visite_min']
    else:
        return [], 0
    for lieu_candidat in lieux_tries[1:]:
        dernier_lieu = itineraire[-1]
        coords1, coords2 = (dernier_lieu['latitude'], dernier_lieu['longitude']), (lieu_candidat['latitude'], lieu_candidat['longitude'])
        temps_trajet = calculer_temps_trajet_a_pied(coords1, coords2)
        if temps_total + temps_trajet + lieu_candidat['temps_visite_min'] <= temps_disponible_min:
            lieu_candidat['trajet_depuis_precedent'] = temps_trajet
            itineraire.append(lieu_candidat)
            temps_total += temps_trajet + lieu_candidat['temps_visite_min']
    return itineraire, temps_total

def trouver_train_ideal(ville_depart, ville_arrivee, heure_min_depart_str):
    """
    Trouve le premier train disponible apr√®s une heure donn√©e pour un trajet direct.
    Retourne un tuple (origine, destination, duree, heure_depart, heure_arrivee) ou None.
    """
    pattern_dep, pattern_arr = f"%{clean_city_name(ville_depart)}%", f"%{clean_city_name(ville_arrivee)}%"
    sql = "SELECT Origine, Destination, strftime('%H:%M:%S', (julianday(Heure_arrivee) - julianday(Heure_depart)) * 86400, 'unixepoch') AS duree, TIME(Heure_depart) AS heure_depart, TIME(Heure_arrivee) AS heure_arrivee FROM tgvmax_trajets WHERE LOWER(Origine) LIKE LOWER(?) AND LOWER(Destination) LIKE LOWER(?) AND TIME(Heure_depart) >= ? ORDER BY TIME(Heure_depart) ASC LIMIT 1"
    cur.execute(sql, (pattern_dep, pattern_arr, heure_min_depart_str))
    return cur.fetchone()

def generer_carte_recommandation(ville_depart, destinations, itineraire_choisi, ville_choisie):
    """G√©n√®re la carte Folium finale avec toutes les informations."""
    ville_depart_nettoyee = clean_city_name(ville_depart)
    try:
        loc_depart = geolocator.geocode(ville_depart_nettoyee)
        m = folium.Map(location=[loc_depart.latitude, loc_depart.longitude], zoom_start=7)
    except:
        m = folium.Map(location=[46.2276, 2.2137], zoom_start=5)

    if loc_depart:
        folium.Marker(location=[loc_depart.latitude, loc_depart.longitude], popup=f"<b>D√©part : {ville_depart}</b>", icon=folium.Icon(color='red', icon='train', prefix='fa')).add_to(m)

    try:
        loc_choisie = geolocator.geocode(clean_city_name(ville_choisie))
        if loc_choisie:
            folium.Circle(location=[loc_choisie.latitude, loc_choisie.longitude], radius=8000, color='red', fill=True, fill_color='red', fill_opacity=0.2).add_to(m)
    except:
        pass

    for dest in destinations:
        if dest[1] != ville_choisie:
            try:
                loc_dest = geolocator.geocode(clean_city_name(dest[1]))
                if loc_dest:
                    folium.Marker(location=[loc_dest.latitude, loc_dest.longitude], popup=f"<i>{dest[1]}</i><br>Dur√©e : {dest[2]}", icon=folium.Icon(color='blue', icon='info-sign')).add_to(m)
            except:
                continue

    for i, lieu in enumerate(itineraire_choisi):
        popup_html = f"<b>{i+1}. {lieu['nom']}</b><br>Visite: {lieu['temps_visite_min']} min"
        if 'trajet_depuis_precedent' in lieu:
            popup_html = f"Trajet: {lieu['trajet_depuis_precedent']} min<br>" + popup_html
        folium.Marker(location=[lieu['latitude'], lieu['longitude']], popup=popup_html, icon=folium.Icon(color='green', icon='camera', prefix='fa')).add_to(m)

    # Return the Folium map object instead of saving it
    return m

# ==============================================================================
# BLOC 3 : LA FONCTION PRINCIPALE POUR GRADIO
# ==============================================================================

def trouver_escapade(ville_depart, heure_depart_souhaitee_str, temps_trajet_max, temps_sur_place_heures, progress=gr.Progress()):
    """
    Cette fonction unique prend toutes les entr√©es de l'utilisateur et retourne
    les sorties format√©es pour l'interface Gradio.
    """
    progress(0, desc="Starting search...")

    # Conversion et pr√©paration des entr√©es
    temps_sur_place_min = int(temps_sur_place_heures * 60)
    # Use the directly provided HH:MM:SS string
    heure_depart_str = heure_depart_souhaitee_str

    # --- 2. Ex√©cuter votre logique de recherche ---
    progress(0.1, desc="Finding potential destinations...")
    destinations_candidates = trouver_destinations_par_temps(ville_depart, temps_trajet_max)
    destinations_uniques_dict = {dest[1]: dest for dest in reversed(destinations_candidates)}
    destinations_uniques_list = list(destinations_uniques_dict.values())

    meilleure_destination_info, meilleur_itineraire_visite, max_score = None, [], -1

    total_destinations = len(destinations_uniques_list)
    for i, dest_info in enumerate(destinations_uniques_list):
        ville_arrivee = dest_info[1] # Get the destination name
        progress((i + 1) / total_destinations * 0.8 + 0.1, desc=f"Analyzing {ville_arrivee}...") # Progress from 0.1 to 0.9

        lieux = get_lieux_touristiques(ville_arrivee)
        if not lieux:
            continue
        lieux_tries = sorted(lieux, key=lambda x: x['score_pertinence'], reverse=True)
        itineraire_ville, _ = creer_itineraire_visite_avec_trajet(lieux_tries, temps_sur_place_min)
        score_actuel = len(itineraire_ville)
        if score_actuel > max_score:
            max_score, meilleure_destination_info, meilleur_itineraire_visite = score_actuel, dest_info, itineraire_ville

    progress(0.9, desc="Formatting results...")
    # --- 3. Formater les sorties pour Gradio ---
    if not meilleure_destination_info:
        resultat_md = "### D√©sol√©, aucune destination trouv√©e...\n" \
                      "Aucune destination ne correspond √† tous vos crit√®res. Essayez d'augmenter le temps de trajet ou le temps sur place."
        return resultat_md, None

    ville_recommandee = meilleure_destination_info[1]
    train_aller = trouver_train_ideal(ville_depart, ville_recommandee, heure_depart_str)

    if not train_aller:
        resultat_md = f"### Destination trouv√©e: {ville_recommandee}, mais...\n" \
                      f"D√©sol√©, aucun train aller trouv√© depuis {ville_depart} apr√®s {heure_depart_str}."
        return resultat_md, None

    # Construction du texte de r√©sultat en Markdown
    resultat_md = f"## üèÜ Votre Escapade Recommand√©e : **{ville_recommandee}**\n---\n"

    # Itin√©raire d√©taill√©
    resultat_md += "### üöÜ Itin√©raire D√©taill√©\n"
    resultat_md += f"**1. Train Aller**\n- D√©part de **{train_aller[0]}** √† **{train_aller[3]}**\n- Arriv√©e √† **{train_aller[1]}** √† **{train_aller[4]}**\n- *Dur√©e : {train_aller[2]}*\n\n"

    resultat_md += "**2. Visite sur Place**\n"
    if meilleur_itineraire_visite:
        heure_arrivee_aller_dt = datetime.strptime(train_aller[4], '%H:%M:%S')
        heure_actuelle_dt = heure_arrivee_aller_dt

        for i, lieu in enumerate(meilleur_itineraire_visite):
            if i > 0:
                temps_trajet_a_pied_min = lieu.get('trajet_depuis_precedent', 0)
                # Ensure addition with timedelta
                heure_arrivee_lieu_dt = heure_actuelle_dt + timedelta(minutes=temps_trajet_a_pied_min)
                resultat_md += f"- *üö∂ Trajet √† pied : ~{temps_trajet_a_pied_min} min (Arriv√©e estim√©e : {heure_arrivee_lieu_dt.strftime('%H:%M')})*\n"
                heure_actuelle_dt = heure_arrivee_lieu_dt

            temps_visite_lieu_min = lieu['temps_visite_min']
             # Ensure addition with timedelta
            heure_fin_visite_lieu_dt = heure_actuelle_dt + timedelta(minutes=temps_visite_lieu_min)
            resultat_md += f"- üèõÔ∏è Visite de **{lieu['nom']}** ({temps_visite_lieu_min} min). (Fin estim√©e : {heure_fin_visite_lieu_dt.strftime('%H:%M')})\n"
            heure_actuelle_dt = heure_fin_visite_lieu_dt

        heure_fin_visite_totale_dt = heure_actuelle_dt
    else:
         resultat_md += "     Aucun itin√©raire de visite d√©taill√© trouv√© pour cette destination dans le temps imparti.\n"
         # If no visit itinerary is found, the end of the visit is just the arrival time + buffer
         heure_arrivee_aller_dt = datetime.strptime(train_aller[4], '%H:%M:%S')
         heure_fin_visite_totale_dt = heure_arrivee_aller_dt + timedelta(minutes=30) # Add a small buffer


    # Calcul du train retour
    heure_min_depart_retour_str = heure_fin_visite_totale_dt.strftime('%H:%M:%S')
    train_retour = trouver_train_ideal(ville_recommandee, ville_depart, heure_min_depart_retour_str)


    resultat_md += "\n**3. Train Retour**\n"
    if train_retour:
        heure_depart_retour_dt = datetime.strptime(train_retour[3], '%H:%M:%S')
        heure_arrivee_retour_dt = datetime.strptime(train_retour[4], '%H:%M:%S')
        temps_trajet_retour_td = heure_arrivee_retour_dt - heure_depart_retour_dt
        if temps_trajet_retour_td.total_seconds() < 0: # Handle overnight journeys
             temps_trajet_retour_td += timedelta(days=1)

        resultat_md += f"- D√©part de **{train_retour[0]}** √† **{train_retour[3]}** ({heure_depart_retour_dt.strftime('%H:%M')})\n- Arriv√©e √† **{train_retour[1]}** √† **{train_retour[4]}** ({heure_arrivee_retour_dt.strftime('%H:%M')})\n- *Dur√©e : {train_retour[2]}*\n"

        # Calcul du temps total
        heure_depart_aller_dt = datetime.strptime(train_aller[3], '%H:%M:%S') # Use departure time of the first train
        temps_total_td = heure_arrivee_retour_dt - heure_depart_aller_dt
        if temps_total_td.total_seconds() < 0: # Handle cases spanning midnight
            temps_total_td += timedelta(days=1)


        heures, remainder = divmod(temps_total_td.total_seconds(), 3600)
        minutes, seconds = divmod(remainder, 60)
        resultat_md += f"\n**Temps total estim√© pour l'ensemble du voyage : {int(heures)}h {int(minutes)}min {int(seconds)}s**"


    else:
         resultat_md += f"- *Aucun train retour trouv√© depuis {ville_recommandee} vers {ville_depart} apr√®s {heure_min_depart_retour_str}.*"


    progress(0.95, desc="Generating map...")
    # G√©n√©ration de la carte (returns Folium map object)
    carte_finale = generer_carte_recommandation(ville_depart, destinations_candidates, meilleur_itineraire_visite, ville_recommandee)

    progress(1.0, desc="Done!")

    # Return the Markdown result and the Folium map object
    return resultat_md, carte_finale


# ==============================================================================
# BLOC 4 : CR√âATION ET LANCEMENT DE L'INTERFACE GRADIO
# ==============================================================================

with gr.Blocks(theme=gr.themes.Soft()) as demo:
    gr.Markdown("# üöÑ Trouvez votre prochaine escapade en train")
    gr.Markdown("Entrez vos crit√®res de voyage pour obtenir une recommandation de destination et un itin√©raire complet.")

    with gr.Row():
        with gr.Column(scale=1):
            ville_depart_input = gr.Textbox(label="üìç Ville de d√©part", value="MARMANDE")
            # Use gr.Textbox for time input
            heure_depart_input = gr.Textbox(label="üïó Heure de d√©part souhait√©e (HH:MM:SS)", value="08:00:00", info="Format HH:MM:SS")
            temps_trajet_max_input = gr.Textbox(label="üöÜ Temps de trajet maximum", value="02:00:00", info="Format HH:MM:SS")
            temps_sur_place_input = gr.Slider(label="‚è≥ Temps souhait√© sur place (en heures)", minimum=1, maximum=12, step=0.5, value=5)
            btn = gr.Button("Trouver mon escapade !", variant="primary")

        with gr.Column(scale=2):
            resultat_output = gr.Markdown(label="Votre Itin√©raire Recommand√©")
            # Use gradio_folium.Folium to display the map object
            carte_output = grf.Folium(label="Carte du Voyage")

    btn.click(fn=trouver_escapade,
              inputs=[ville_depart_input, heure_depart_input, temps_trajet_max_input, temps_sur_place_input],
              outputs=[resultat_output, carte_output]) # carte_output is now a Folium component

    gr.Examples(
        examples=[
            ["ANTIBES", "09:00:00", "02:00:00", 5],
            ["NICE", "09:00:00", "01:30:00", 4],
            ["BORDEAUX ST JEAN", "07:30:00", "02:00:00", 8],
            ["MARSEILLE ST CHARLES", "10:00:00", "01:45:00", 5]
        ],
        inputs=[ville_depart_input, heure_depart_input, temps_trajet_max_input, temps_sur_place_input],
    )

print("üöÄ Lancement de l'interface Gradio...")
# share=True cr√©e un lien public temporaire pour partager votre application
demo.launch(debug=True, share=True)

# ==============================================================================
# BLOC 1 : INSTALLATION, IMPORTS ET CONFIGURATION
# ==============================================================================

print("üöÄ Installation des biblioth√®ques...")
!pip install gradio geopy folium pandas gradio-folium -q
print("‚úÖ Installation termin√©e.")

import sqlite3
import pandas as pd
from geopy.geocoders import Nominatim
from geopy.distance import geodesic
import folium
import requests
import re
from datetime import datetime, timedelta
import gradio as gr
import gradio_folium as grf

# --- Connexion √† la base de donn√©es ---
db_path = "/content/drive/MyDrive/Colab Notebook/SNCF/tgvmax.db"
try:
    conn = sqlite3.connect(db_path, check_same_thread=False)
    cur = conn.cursor()
    print("‚úÖ Connexion √† la base de donn√©es r√©ussie.")
except Exception as e:
    print(f"‚ùå Erreur de connexion √† la base de donn√©es : {e}")

# --- Initialisation du g√©ocodeur ---
geolocator = Nominatim(user_agent="mon_appli_itineraire_gradio", timeout=10)

# ==============================================================================
# BLOC 2 : VOS FONCTIONS UTILITAIRES ET PRINCIPALES (MODIFI√âES)
# ==============================================================================

def clean_city_name(city_name):
    if not isinstance(city_name, str):
        return ""
    # Remove "(intramuros)" and any leading/trailing whitespace
    cleaned_name = re.sub(r'\s*\([^)]*\)$', '', city_name).strip()
    # --- MODIFICATION ICI ---
    # Be less aggressive in removing station names, specifically keep "ST CHARLES"
    cleaned_name = re.sub(r'\s*(MATABIAU|VILLE BOURBON|PART DIEU|SAINT LAUD|MONTPARNASSE|EST|NORD|LYON|AUSTERLITZ)\s*$', '', cleaned_name, flags=re.IGNORECASE).strip()
    # Specifically handle "TOULOUSE MATABIAU" and "MARSEILLE ST CHARLES"
    if cleaned_name.lower() == "toulouse":
        return "TOULOUSE MATABIAU" # Use full station name if that's how it is in the database
    if cleaned_name.lower() == "marseille":
         return "MARSEILLE ST CHARLES" # Use full station name
    # Remove "ST JEAN" only if it's at the end and not part of a larger name like "ST JEAN DE LUZ"
    cleaned_name = re.sub(r'\s*ST JEAN$', '', cleaned_name, flags=re.IGNORECASE).strip()

    return cleaned_name

def estimer_temps_visite(tags):
    if tags.get('tourism') == 'museum' or tags.get('historic') == 'castle':
        return 120
    if tags.get('historic') in ['cathedral', 'church']:
        return 45
    if tags.get('tourism') == 'attraction' or tags.get('historic') == 'monument':
        return 30
    if tags.get('leisure') == 'park':
        return 60
    return 20

def calculer_temps_trajet_a_pied(coords1, coords2, vitesse_kmh=4.5):
    if not coords1 or not coords2:
        return 0
    try:
        distance_km = geodesic(coords1, coords2).kilometers
    except ValueError:
        return 0
    return round((distance_km / vitesse_kmh) * 60)

# <-- MODIFI√â : La fonction accepte maintenant une date de d√©part (but not used in the query)
def trouver_destinations_par_temps(ville_depart, temps_trajet_max_str):
    """
    Trouve les destinations possibles pour une dur√©e de trajet donn√©e.
    NOTE : This function still relies on time duration only, not specific dates from the database.
    If you need to filter destinations based on trains available *after* a specific date,
    this function would need significant modification to include date filtering in the SQL query.
    """
    pattern = f"%{clean_city_name(ville_depart)}%"
    # The query still filters only on time duration
    sql = """
        SELECT
            Origine,
            Destination,
            strftime('%H:%M:%S', (julianday(Heure_arrivee) - julianday(Heure_depart)) * 86400, 'unixepoch') AS duree,
            TIME(Heure_depart) AS heure_depart,
            TIME(Heure_arrivee) AS heure_arrivee
        FROM tgvmax_trajets
        WHERE
            LOWER(Origine) LIKE LOWER(?)
            AND duree > '00:00:00'
            AND duree <= ?
        ORDER BY duree
    """
    cur.execute(sql, (pattern, temps_trajet_max_str))
    return cur.fetchall()

def get_lieux_touristiques(nom_ville):
    nom_ville_nettoye = clean_city_name(nom_ville)
    try:
        location = geolocator.geocode(nom_ville_nettoye, exactly_one=True)
        if not location or 'boundingbox' not in location.raw:
            return []
    except Exception:
        return []
    bbox = location.raw['boundingbox']
    s, n, w, e = [float(x) for x in bbox]
    overpass_url = "http://overpass-api.de/api/interpreter"
    overpass_query = f"""[out:json][timeout:25];(node["tourism"~"museum|attraction|gallery|viewpoint"]({s},{w},{n},{e});way["tourism"~"museum|attraction|gallery|viewpoint"]({s},{w},{n},{e});node["historic"~"castle|monument|ruins|cathedral|church"]({s},{w},{n},{e});way["historic"~"castle|monument|ruins|cathedral|church"]({s},{w},{n},{e}););out center;"""
    try:
        response = requests.get(overpass_url, params={'data': overpass_query})
        response.raise_for_status()
        data = response.json()
        lieux = []
        for element in data.get('elements', []):
            tags = element.get('tags', {})
            if 'name' not in tags:
                continue
            lat, lon = (element.get('lat'), element.get('lon')) if element['type'] == 'node' else (element.get('center', {}).get('lat'), element.get('center', {}).get('lon'))
            if not lat or not lon:
                continue
            lieux.append({'nom': tags['name'], 'latitude': lat, 'longitude': lon, 'tags': tags, 'temps_visite_min': estimer_temps_visite(tags), 'score_pertinence': 1 if 'wikipedia' in tags else 0})
        return lieux
    except requests.exceptions.RequestException:
        return []

def creer_itineraire_visite_avec_trajet(lieux_tries, temps_disponible_min):
    itineraire, temps_total = [], 0
    if not lieux_tries:
        return [], 0
    premier_lieu = lieux_tries[0]
    if premier_lieu['temps_visite_min'] <= temps_disponible_min:
        itineraire.append(premier_lieu)
        temps_total += premier_lieu['temps_visite_min']
    else:
        return [], 0
    for lieu_candidat in lieux_tries[1:]:
        dernier_lieu = itineraire[-1]
        coords1, coords2 = (dernier_lieu['latitude'], dernier_lieu['longitude']), (lieu_candidat['latitude'], lieu_candidat['longitude'])
        temps_trajet = calculer_temps_trajet_a_pied(coords1, coords2)
        if temps_total + temps_trajet + lieu_candidat['temps_visite_min'] <= temps_disponible_min:
            lieu_candidat['trajet_depuis_precedent'] = temps_trajet
            itineraire.append(lieu_candidat)
            temps_total += temps_trajet + lieu_candidat['temps_visite_min']
    return itineraire, temps_total

def trouver_train_ideal(ville_depart, ville_arrivee, date_min_depart, heure_min_depart_str):
    """
    Trouve le premier train disponible after a given date and time for a direct journey.
    Args:
        ville_depart (str): The departure city.
        ville_arrivee (str): The arrival city.
        date_min_depart (datetime.date): The minimum departure date.
        heure_min_depart_str (str): The minimum departure time in HH:MM:SS format.

    Returns:
        tuple: (origine, destination, duree, heure_depart, heure_arrivee) or None.
    """
    pattern_dep = f"%{clean_city_name(ville_depart)}%"
    pattern_arr = f"%{clean_city_name(ville_arrivee)}%"

    # Format the date for SQL query
    date_str = date_min_depart.strftime('%Y-%m-%d')

    # --- MODIFICATION PRINCIPALE ICI ---
    # Modify the SQL query to use separate date and time conditions
    sql = """
    SELECT Origine, Destination,
           strftime('%H:%M:%S', (julianday(Heure_arrivee) - julianday(Heure_depart)) * 86400, 'unixepoch') AS duree,
           TIME(Heure_depart) AS heure_depart,
           TIME(Heure_arrivee) AS heure_arrivee
    FROM tgvmax_trajets
    WHERE LOWER(Origine) LIKE LOWER(?)
      AND LOWER(Destination) LIKE LOWER(?)
      AND (
           (DATE(Heure_depart) > ?) -- Departure date is after the minimum date
           OR
           (DATE(Heure_depart) = ? AND TIME(Heure_depart) >= ?) -- Or departure date is the same and time is after or equal
          )
    ORDER BY Heure_depart ASC -- Order by the full datetime
    LIMIT 1
    """

    # --- Ajout de logs pour le d√©bogage ---
    print(f"DEBUG: SQL Query for trouver_train_ideal: {sql}")
    print(f"DEBUG: Parameters: ('{pattern_dep}', '{pattern_arr}', '{date_str}', '{date_str}', '{heure_min_depart_str}')")

    try:
        cur.execute(sql, (pattern_dep, pattern_arr, date_str, date_str, heure_min_depart_str))
        result = cur.fetchone()
        print(f"DEBUG: Query Result: {result}")
        return result
    except sqlite3.Error as e:
        print(f"Database error in trouver_train_ideal: {e}")
        return None
    except Exception as e:
        print(f"An error occurred in trouver_train_ideal: {e}")
        return None


def generer_carte_recommandation(ville_depart, destinations, itineraire_choisi, ville_choisie):
    """G√©n√®re la carte Folium finale avec toutes les informations."""
    ville_depart_nettoyee = clean_city_name(ville_depart)
    try:
        loc_depart = geolocator.geocode(ville_depart_nettoyee)
        m = folium.Map(location=[loc_depart.latitude, loc_depart.longitude], zoom_start=7)
    except:
        m = folium.Map(location=[46.2276, 2.2137], zoom_start=5)

    if loc_depart:
        folium.Marker(location=[loc_depart.latitude, loc_depart.longitude], popup=f"<b>D√©part : {ville_depart}</b>", icon=folium.Icon(color='red', icon='train', prefix='fa')).add_to(m)

    try:
        loc_choisie = geolocator.geocode(clean_city_name(ville_choisie))
        if loc_choisie:
            folium.Circle(location=[loc_choisie.latitude, loc_choisie.longitude], radius=8000, color='red', fill=True, fill_color='red', fill_opacity=0.2).add_to(m)
    except:
        pass

    for dest in destinations:
        if dest[1] != ville_choisie:
            try:
                loc_dest = geolocator.geocode(clean_city_name(dest[1]))
                if loc_dest:
                    folium.Marker(location=[loc_dest.latitude, loc_dest.longitude], popup=f"<i>{dest[1]}</i><br>Dur√©e : {dest[2]}", icon=folium.Icon(color='blue', icon='info-sign')).add_to(m)
            except:
                continue

    for i, lieu in enumerate(itineraire_choisi):
        popup_html = f"<b>{i+1}. {lieu['nom']}</b><br>Visite: {lieu['temps_visite_min']} min"
        if 'trajet_depuis_precedent' in lieu:
            popup_html = f"Trajet: {lieu['trajet_depuis_precedent']} min<br>" + popup_html
        folium.Marker(location=[lieu['latitude'], lieu['longitude']], popup=popup_html, icon=folium.Icon(color='green', icon='camera', prefix='fa')).add_to(m)

    # Return the Folium map object instead of saving it
    return m

# ==============================================================================
# BLOC 3 : LA FONCTION PRINCIPALE POUR GRADIO
# ==============================================================================

def trouver_escapade(ville_depart, date_heure_depart_souhaitee_dt, temps_trajet_max, temps_sur_place_heures, progress=gr.Progress()):
    """
    Cette fonction unique prend toutes les entr√©es de l'utilisateur et retourne
    les sorties format√©es pour l'interface Gradio.
    """
    progress(0, desc="Starting search...")

    # Add a check for None and provide a default value if necessary
    if date_heure_depart_souhaitee_dt is None:
        return "### Erreur: Veuillez s√©lectionner une date et une heure de d√©part.", None

    # Conversion et pr√©paration des entr√©es
    temps_sur_place_min = int(temps_sur_place_heures * 60)

    # --- 2. Ex√©cuter votre logique de recherche ---
    progress(0.1, desc="Finding potential destinations...")
    # Pass only the time constraint to trouver_destinations_par_temps as it doesn't use the full datetime
    destinations_candidates = trouver_destinations_par_temps(ville_depart, temps_trajet_max)

    destinations_uniques_dict = {dest[1]: dest for dest in reversed(destinations_candidates)}
    destinations_uniques_list = list(destinations_uniques_dict.values())

    # --- MODIFICATION ICI ---
    # Filter destinations to keep only those with a valid round trip
    valid_destinations = []
    for dest_info in destinations_uniques_list:
        ville_arrivee = dest_info[1]
        # Check for a valid "aller" train
        train_aller = trouver_train_ideal(ville_depart, ville_arrivee, date_heure_depart_souhaitee_dt.date(), date_heure_depart_souhaitee_dt.strftime('%H:%M:%S'))

        if train_aller:
            # Calculate estimated end of visit time
            heure_arrivee_aller_dt = datetime.combine(date_heure_depart_souhaitee_dt.date(), datetime.strptime(train_aller[4], '%H:%M:%S').time())
            if train_aller[4] < train_aller[3]: # Handle overnight arrival
                heure_arrivee_aller_dt += timedelta(days=1)
            heure_fin_visite_totale_dt = heure_arrivee_aller_dt + timedelta(minutes=temps_sur_place_min)

            # Check for a valid "retour" train on the same day
            train_retour = trouver_train_ideal(ville_arrivee, ville_depart, heure_fin_visite_totale_dt.date(), heure_fin_visite_totale_dt.strftime('%H:%M:%S'))

            # If no train is found on the same day, check for the first train the next day
            if not train_retour:
                 jour_suivant_dt = heure_fin_visite_totale_dt + timedelta(days=1)
                 train_retour = trouver_train_ideal(ville_arrivee, ville_depart, jour_suivant_dt.date(), jour_suivant_dt.replace(hour=0, minute=0, second=0).strftime('%H:%M:%S'))


            if train_retour:
                # If both aller and retour trains are found, add the destination to valid_destinations
                valid_destinations.append((dest_info, train_aller, train_retour))
            else:
                print(f"DEBUG: No return train found for {ville_arrivee}")
        else:
            print(f"DEBUG: No outbound train found for {ville_arrivee}")


    meilleure_destination_info, meilleur_itineraire_visite, max_score = None, [], -1
    best_train_aller, best_train_retour = None, None

    total_valid_destinations = len(valid_destinations)
    for i, (dest_info, train_aller, train_retour) in enumerate(valid_destinations):
        ville_arrivee = dest_info[1]
        progress((i + 1) / total_valid_destinations * 0.8 + 0.1, desc=f"Analyzing {ville_arrivee}...")

        lieux = get_lieux_touristiques(ville_arrivee)
        lieux_tries = sorted(lieux, key=lambda x: x['score_pertinence'], reverse=True)
        itineraire_ville, _ = creer_itineraire_visite_avec_trajet(lieux_tries, temps_sur_place_min)
        score_actuel = len(itineraire_ville)

        if score_actuel > max_score:
            max_score = score_actuel
            meilleure_destination_info = dest_info
            meilleur_itineraire_visite = itineraire_ville
            best_train_aller = train_aller
            best_train_retour = train_retour


    progress(0.9, desc="Formatting results...")
    # --- 3. Formater les sorties pour Gradio ---
    if not meilleure_destination_info:
        resultat_md = "### D√©sol√©, aucune destination trouv√©e...\n" \
                      "Aucune destination ne correspond √† tous vos crit√®res (trajet aller-retour possible et temps sur place suffisant pour au moins 1 activit√©)."
        return resultat_md, None

    ville_recommandee = meilleure_destination_info[1]
    train_aller = best_train_aller
    train_retour = best_train_retour


    # Construction du texte de r√©sultat en Markdown
    resultat_md = f"## üèÜ Votre Escapade Recommand√©e : **{ville_recommandee}**\n---\n"

    # Itin√©raire d√©taill√©
    resultat_md += "### üöÜ Itin√©raire D√©taill√©\n"
    # Display the full date and time for clarity
    resultat_md += f"**1. Train Aller**\n- D√©part de **{train_aller[0]}** le {date_heure_depart_souhaitee_dt.strftime('%Y-%m-%d')} √† **{train_aller[3]}**\n- Arriv√©e √† **{train_aller[1]}** √† **{train_aller[4]}** ({date_heure_depart_souhaitee_dt.strftime('%Y-%m-%d') if train_aller[4] >= train_aller[3] else (date_heure_depart_souhaitee_dt + timedelta(days=1)).strftime('%Y-%m-%d')})\n- *Dur√©e : {train_aller[2]}*\n\n"

    resultat_md += "**2. Visite sur Place**\n"
    if meilleur_itineraire_visite:
        # Calculate the actual arrival datetime for the first train
        # Assuming the date of arrival is the same as the departure date for simplicity within the travel time limit
        heure_arrivee_aller_dt = datetime.combine(date_heure_depart_souhaitee_dt.date(), datetime.strptime(train_aller[4], '%H:%M:%S').time())
        # Adjust for overnight arrival if necessary
        if train_aller[4] < train_aller[3]:
             heure_arrivee_aller_dt += timedelta(days=1)


        heure_actuelle_dt = heure_arrivee_aller_dt

        for i, lieu in enumerate(meilleur_itineraire_visite):
            if i > 0:
                temps_trajet_a_pied_min = lieu.get('trajet_depuis_precedent', 0)
                heure_arrivee_lieu_dt = heure_actuelle_dt + timedelta(minutes=temps_trajet_a_pied_min)
                resultat_md += f"- *üö∂ Trajet √† pied : ~{temps_trajet_a_pied_min} min (Arriv√©e estim√©e : {heure_arrivee_lieu_dt.strftime('%H:%M')})*\n"
                heure_actuelle_dt = heure_arrivee_lieu_dt

            temps_visite_lieu_min = lieu['temps_visite_min']
            heure_fin_visite_lieu_dt = heure_actuelle_dt + timedelta(minutes=temps_visite_lieu_min)
            resultat_md += f"- üèõÔ∏è Visite de **{lieu['nom']}** ({temps_visite_lieu_min} min). (Fin estim√©e : {heure_fin_visite_lieu_dt.strftime('%H:%M')})\n"
            heure_actuelle_dt = heure_fin_visite_lieu_dt

        heure_fin_visite_totale_dt = heure_actuelle_dt
    else:
         resultat_md += "     Aucun itin√©raire de visite d√©taill√© trouv√© pour cette destination dans le temps imparti.\n"
         # If no visit itinerary is found, the end of the visit is just the arrival time + buffer
         heure_arrivee_aller_dt = datetime.combine(date_heure_depart_souhaitee_dt.date(), datetime.strptime(train_aller[4], '%H:%M:%S').time())
         # Adjust for overnight arrival if necessary
         if train_aller[4] < train_aller[3]:
             heure_arrivee_aller_dt += timedelta(days=1)
         heure_fin_visite_totale_dt = heure_arrivee_aller_dt + timedelta(minutes=30) # Add a small buffer


    # --- MODIFICATION ICI ---
    # Trouver le train retour id√©al
    # The return train should be on the same date or the next day depending on the end of visit time
    heure_min_depart_retour_dt = heure_fin_visite_totale_dt
    # Check for a valid "retour" train on the same day
    train_retour = trouver_train_ideal(ville_recommandee, ville_depart, heure_min_depart_retour_dt.date(), heure_min_depart_retour_dt.strftime('%H:%M:%S'))

    # If no train is found on the same day after the visit, check for the first train the next day
    if not train_retour:
         jour_suivant_dt = heure_fin_visite_totale_dt + timedelta(days=1)
         train_retour = trouver_train_ideal(ville_recommandee, ville_depart, jour_suivant_dt.date(), jour_suivant_dt.replace(hour=0, minute=0, second=0).strftime('%H:%M:%S'))
         if train_retour:
              resultat_md += f"\n*Note: Aucun train retour trouv√© le jour m√™me. Recherche du premier train le lendemain.*"


    resultat_md += "\n**3. Train Retour**\n"
    if train_retour:
        # Calculate the actual departure datetime for the return train
        heure_depart_retour_dt = datetime.combine(heure_fin_visite_totale_dt.date(), datetime.strptime(train_retour[3], '%H:%M:%S').time())
        # Adjust for next day departure if the returned time is earlier than the end of visit time
        if heure_depart_retour_dt < heure_fin_visite_totale_dt:
             heure_depart_retour_dt += timedelta(days=1)

        # Calculate the actual arrival datetime for the return train
        heure_arrivee_retour_dt = datetime.combine(heure_depart_retour_dt.date(), datetime.strptime(train_retour[4], '%H:%M:%S').time())
        # Adjust for overnight arrival
        if heure_arrivee_retour_dt < heure_depart_retour_dt:
             heure_arrivee_retour_dt += timedelta(days=1)


        resultat_md += f"- D√©part de **{train_retour[0]}** le {heure_depart_retour_dt.strftime('%Y-%m-%d')} √† **{train_retour[3]}** ({heure_depart_retour_dt.strftime('%H:%M')})\n- Arriv√©e √† **{train_retour[1]}** √† **{train_retour[4]}** ({heure_arrivee_retour_dt.strftime('%Y-%m-%d %H:%M')})\n- *Dur√©e : {train_retour[2]}*\n"

        # Calcul du temps total
        heure_depart_aller_dt = datetime.combine(date_heure_depart_souhaitee_dt.date(), datetime.strptime(train_aller[3], '%H:%M:%S').time())
        # Adjust for overnight departure of the first train if necessary
        if train_aller[3] < date_heure_depart_souhaitee_dt.strftime('%H:%M:%S'):
             heure_depart_aller_dt += timedelta(days=1)


        temps_total_td = heure_arrivee_retour_dt - heure_depart_aller_dt
        # Handle cases spanning midnight over multiple days
        # If the total duration is negative, it means the end is on the next day or later
        if temps_total_td.total_seconds() < 0:
            temps_total_td += timedelta(days=((heure_arrivee_retour_dt.date() - heure_depart_aller_dt.date()).days))


        heures, remainder = divmod(temps_total_td.total_seconds(), 3600)
        minutes, seconds = divmod(remainder, 60)
        resultat_md += f"\n**Temps total estim√© pour l'ensemble du voyage : {int(heures)}h {int(minutes)}min {int(seconds)}s**"


    else:
         resultat_md += f"- *Aucun train retour trouv√© depuis {ville_recommandee} vers {ville_depart} apr√®s {heure_fin_visite_totale_dt.strftime('%Y-%m-%d %H:%M:%S')}."


    progress(0.95, desc="Generating map...")
    # G√©n√©ration de la carte (returns Folium map object)
    carte_finale = generer_carte_recommandation(ville_depart, destinations_candidates, meilleur_itineraire_visite, ville_recommandee)

    progress(1.0, desc="Done!")

    # Return the Markdown result and the Folium map object
    return resultat_md, carte_finale


# ==============================================================================
# BLOC 4 : CR√âATION ET LANCEMENT DE L'INTERFACE GRADIO
# ==============================================================================

with gr.Blocks(theme=gr.themes.Soft()) as demo:
    gr.Markdown("# üöÑ Trouvez votre prochaine escapade en train")
    gr.Markdown("Entrez vos crit√®res de voyage pour obtenir une recommandation de destination et un itin√©raire complet.")

    with gr.Row():
        with gr.Column(scale=1):
            ville_depart_input = gr.Textbox(label="üìç Ville de d√©part", value="PARIS (intramuros)")
            # Use gr.DateTime for date and time input
            heure_depart_input = gr.DateTime(label="üïó Date et heure de d√©part souhait√©es", value=datetime(2024, 9, 8, 8, 0, 0), type="pydatetime")
            temps_trajet_max_input = gr.Textbox(label="üöÜ Temps de trajet maximum", value="02:30:00", info="Format HH:MM:SS")
            temps_sur_place_input = gr.Slider(label="‚è≥ Temps souhait√© sur place (en heures)", minimum=1, maximum=12, step=0.5, value=6)
            btn = gr.Button("Trouver mon escapade !", variant="primary")

        with gr.Column(scale=2):
            resultat_output = gr.Markdown(label="Votre Itin√©raire Recommand√©")
            # Use gradio_folium.Folium to display the map object
            carte_output = grf.Folium(label="Carte du Voyage")

    btn.click(fn=trouver_escapade,
              inputs=[ville_depart_input, heure_depart_input, temps_trajet_max_input, temps_sur_place_input],
              outputs=[resultat_output, carte_output]) # carte_output is now a Folium component

    # Update examples to use datetime objects
    gr.Examples(
        examples=[
            ["LYON (gares)", datetime(2024, 9, 9, 9, 0, 0), "01:30:00", 4],
            ["BORDEAUX ST JEAN", datetime(2024, 9, 10, 7, 30, 0), "02:00:00", 8],
            ["MARSEILLE ST CHARLES", datetime(2024, 9, 11, 10, 0, 0), "01:45:00", 5],
            ["MARMANDE", datetime(2024, 9, 12, 9, 0, 0), "02:00:00", 5]
        ],
        inputs=[ville_depart_input, heure_depart_input, temps_trajet_max_input, temps_sur_place_input],
    )

print("üöÄ Lancement de l'interface Gradio...")
# share=True cr√©e un lien public temporaire pour partager votre application
demo.launch(debug=True, share=True)